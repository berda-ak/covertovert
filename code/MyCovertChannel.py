from CovertChannelBase import CovertChannelBase
from scapy.all import sniff,IP,ICMP,send
import time

class MyCovertChannel(CovertChannelBase):
    """
    - You are not allowed to change the file name and class name.
    - You can edit the class in any way you want (e.g. adding helper functions); however, there must be a "send" and a "receive" function, the covert channel will be triggered by calling these functions.
    """
    def __init__(self):
        """
        - You can edit __init__.
        """
        super().__init__()
        self.message = ""
        self.flag = False
        self.packet_count = 0
        self.bits=[]
        self.b_num = 0
        self.start_flag = True
       
    

    def wait(self):
        time.sleep(self.wait_time )
            
    def send(self, log_file_name, first_burst_num, second_burst_num,wait_time,ip):
        """
        This function sends a random message generated by generate_random_binary_message_with_logging and encrypts 
        it by using packet bursting method. Packets in bursts are ICMP packets, number of packets are determined
        in config.json file for 0 and 1 as optimum values. They are sent by using scapy's send function.

        Constraints: Parameters must be determined such that the difference between number of packet for 0 and 1 
        are at least 2. Moreover first_burst_num, second_burst_num, wait time must be the same for receive and send functions.
        """

        # 1 is 2 packets, 
        # 0 is 4 packets
        rec_IP = ip
        self.wait_time = wait_time
        starting_time = time.time()

        # for 16 char message performance set to min_length=16 ,max_length=16
        binary_message = self.generate_random_binary_message_with_logging(log_file_name, min_length=50 ,max_length=100)
        for i in range(len(binary_message)):
            if binary_message[i] ==  '1':
                #send_two_packets change packet numbers give bigger to test the code, after you are sure you have no error proceed to smaller packet numbers
                for j in range(first_burst_num):
                    packet1 = IP(dst = rec_IP) / ICMP() 
                    super().send(packet1) 
                self.wait()
                
            else:
                #send_three_packets
                for j in range(second_burst_num):
                    packet1 = IP(dst = rec_IP) / ICMP() 
                    super().send(packet1) 
                self.wait()

        last_packet = IP(dst = rec_IP) / ICMP()
        super().send(last_packet)

        #code for performance test
        performance = 128/(time.time() - starting_time)
        print("Covert Channel Performance: ", performance)

    def receive(self, first_burst_num, second_burst_num, log_file_name,wait_time):
        """
        Receives and decodes the message sent by the send function in packet bursts.
         It counts the number of packets in a time interval and decides the bit value.
          After each 8 bits it, decides the corresponding character. After receiving '.'
          converts to corresponding string value and logs to file given by Receiver.log

        Constraints: Parameters must be determined such that the difference between number of packet for 0 and 1 
        are at least 2. Moreover first_burst_num, second_burst_num, wait time must be the same for receive and send functions.
        """
        
        self.wait_time = wait_time
        def receivePacket(packet):

            if self.start_flag:
                self.start_time = time.time()
                self.start_flag = False

            

            in_time_interval = (time.time() - self.start_time ) > self.wait_time 

            
            if packet and packet.haslayer(ICMP) and packet[ICMP].type == 8: 
                self.packet_count+=1

            if(first_burst_num<second_burst_num):
                if in_time_interval:
                #print("packet count", self.packet_count)
                    if self.packet_count < (first_burst_num+1):
                        self.bits.append(1)
                        self.b_num+=1
                        self.packet_count = 0
                        self.start_flag = True
                    else:
                        self.bits.append(0)
                        self.b_num+=1
                        self.packet_count = 0
                        self.start_flag = True
            else:
                if in_time_interval:
                    #print("packet count", self.packet_count)
                    if self.packet_count < (second_burst_num+1):
                        self.bits.append(1)
                        self.b_num+=1
                        self.packet_count = 0
                        self.start_flag = True
                    else:
                        self.bits.append(0)
                        self.b_num+=1
                        self.packet_count = 0
                        self.start_flag = True
            
            
            

            if self.b_num == 8:
                #print("bits :", ''.join(map(str, self.bits)))
                self.message += self.convert_eight_bits_to_character(''.join(map(str, self.bits)))
                self.b_num = 0
                self.bits = []
                #print(self.message)

                if self.message[-1] == '.': 
                    #print("message", self.message) 
                    self.log_message(message = self.message, log_file_name=log_file_name)
                    self.flag = True 


        
    
        def getFlag(packet):
            return self.flag

        

        sniff(filter="icmp", prn = receivePacket, stop_filter = getFlag) 

              
